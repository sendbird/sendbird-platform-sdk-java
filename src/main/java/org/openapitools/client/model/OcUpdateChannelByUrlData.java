/*
 * Sendbird Platform SDK
 * Sendbird Platform API SDK  https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@sendbird.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.sendbird.client.JSON;


/**
 * OcUpdateChannelByUrlData
 */
@JsonPropertyOrder({
  OcUpdateChannelByUrlData.JSON_PROPERTY_CHANNEL_URL,
  OcUpdateChannelByUrlData.JSON_PROPERTY_NAME,
  OcUpdateChannelByUrlData.JSON_PROPERTY_COVER_URL,
  OcUpdateChannelByUrlData.JSON_PROPERTY_COVER_FILE,
  OcUpdateChannelByUrlData.JSON_PROPERTY_CUSTOM_TYPE,
  OcUpdateChannelByUrlData.JSON_PROPERTY_DATA,
  OcUpdateChannelByUrlData.JSON_PROPERTY_OPERATOR_IDS,
  OcUpdateChannelByUrlData.JSON_PROPERTY_OPERATORS
})
@JsonTypeName("ocUpdateChannelByUrlData")
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-24T21:22:01.103596+09:00[Asia/Seoul]")
public class OcUpdateChannelByUrlData {
  public static final String JSON_PROPERTY_CHANNEL_URL = "channel_url";
  private String channelUrl;

  public static final String JSON_PROPERTY_NAME = "name";
  private String name;

  public static final String JSON_PROPERTY_COVER_URL = "cover_url";
  private String coverUrl;

  public static final String JSON_PROPERTY_COVER_FILE = "cover_file";
  private File coverFile;

  public static final String JSON_PROPERTY_CUSTOM_TYPE = "custom_type";
  private String customType;

  public static final String JSON_PROPERTY_DATA = "data";
  private String data;

  public static final String JSON_PROPERTY_OPERATOR_IDS = "operator_ids";
  private List<String> operatorIds = new ArrayList<>();

  public static final String JSON_PROPERTY_OPERATORS = "operators";
  private List<String> operators = new ArrayList<>();

  public OcUpdateChannelByUrlData() { 
  }

  public OcUpdateChannelByUrlData channelUrl(String channelUrl) {
    this.channelUrl = channelUrl;
    return this;
  }

   /**
   * Specifies the URL of the channel to update.
   * @return channelUrl
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the URL of the channel to update.")
  @JsonProperty(JSON_PROPERTY_CHANNEL_URL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getChannelUrl() {
    return channelUrl;
  }


  @JsonProperty(JSON_PROPERTY_CHANNEL_URL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setChannelUrl(String channelUrl) {
    this.channelUrl = channelUrl;
  }


  public OcUpdateChannelByUrlData name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Specifies the channel topic, or the name of the channel. The length is limited to 191 characters.
   * @return name
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the channel topic, or the name of the channel. The length is limited to 191 characters.")
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(String name) {
    this.name = name;
  }


  public OcUpdateChannelByUrlData coverUrl(String coverUrl) {
    this.coverUrl = coverUrl;
    return this;
  }

   /**
   * Specifies the URL of the cover image. The length is limited to 2,048 characters.
   * @return coverUrl
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the URL of the cover image. The length is limited to 2,048 characters.")
  @JsonProperty(JSON_PROPERTY_COVER_URL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getCoverUrl() {
    return coverUrl;
  }


  @JsonProperty(JSON_PROPERTY_COVER_URL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCoverUrl(String coverUrl) {
    this.coverUrl = coverUrl;
  }


  public OcUpdateChannelByUrlData coverFile(File coverFile) {
    this.coverFile = coverFile;
    return this;
  }

   /**
   * Uploads the file for the channel cover image.
   * @return coverFile
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Uploads the file for the channel cover image.")
  @JsonProperty(JSON_PROPERTY_COVER_FILE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public File getCoverFile() {
    return coverFile;
  }


  @JsonProperty(JSON_PROPERTY_COVER_FILE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCoverFile(File coverFile) {
    this.coverFile = coverFile;
  }


  public OcUpdateChannelByUrlData customType(String customType) {
    this.customType = customType;
    return this;
  }

   /**
   * Specifies the custom channel type which is used for channel grouping. The length is limited to 128 characters.&lt;br /&gt;&lt;br /&gt; Custom types are also used within Sendbird&#39;s [Advanced analytics](/docs/chat/v3/platform-api/guides/advanced-analytics) to segment metrics, which enables the sub-classification of data views.
   * @return customType
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the custom channel type which is used for channel grouping. The length is limited to 128 characters.<br /><br /> Custom types are also used within Sendbird's [Advanced analytics](/docs/chat/v3/platform-api/guides/advanced-analytics) to segment metrics, which enables the sub-classification of data views.")
  @JsonProperty(JSON_PROPERTY_CUSTOM_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getCustomType() {
    return customType;
  }


  @JsonProperty(JSON_PROPERTY_CUSTOM_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCustomType(String customType) {
    this.customType = customType;
  }


  public OcUpdateChannelByUrlData data(String data) {
    this.data = data;
    return this;
  }

   /**
   * Specifies additional channel information such as a long description of the channel or &#x60;JSON&#x60; formatted string.
   * @return data
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies additional channel information such as a long description of the channel or `JSON` formatted string.")
  @JsonProperty(JSON_PROPERTY_DATA)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getData() {
    return data;
  }


  @JsonProperty(JSON_PROPERTY_DATA)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setData(String data) {
    this.data = data;
  }


  public OcUpdateChannelByUrlData operatorIds(List<String> operatorIds) {
    this.operatorIds = operatorIds;
    return this;
  }

  public OcUpdateChannelByUrlData addOperatorIdsItem(String operatorIdsItem) {
    this.operatorIds.add(operatorIdsItem);
    return this;
  }

   /**
   * Specifies an array of one or more user IDs to register as operators of the channel. The maximum allowed number of operators per channel is 100. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.&lt;br/&gt;&lt;br/&gt;  Operators cannot view messages that have been [moderated by](/docs/chat/v3/platform-api/guides/filter-and-moderation) the domain filter or profanity filter. Only the sender will be notified that the message has been blocked.
   * @return operatorIds
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies an array of one or more user IDs to register as operators of the channel. The maximum allowed number of operators per channel is 100. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.<br/><br/>  Operators cannot view messages that have been [moderated by](/docs/chat/v3/platform-api/guides/filter-and-moderation) the domain filter or profanity filter. Only the sender will be notified that the message has been blocked.")
  @JsonProperty(JSON_PROPERTY_OPERATOR_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<String> getOperatorIds() {
    return operatorIds;
  }


  @JsonProperty(JSON_PROPERTY_OPERATOR_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setOperatorIds(List<String> operatorIds) {
    this.operatorIds = operatorIds;
  }


  public OcUpdateChannelByUrlData operators(List<String> operators) {
    this.operators = operators;
    return this;
  }

  public OcUpdateChannelByUrlData addOperatorsItem(String operatorsItem) {
    this.operators.add(operatorsItem);
    return this;
  }

   /**
   * (Deprecated) Specifies the string IDs of the users registered as channel operators. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.
   * @return operators
  **/
  @jakarta.annotation.Nonnull
  @ApiModelProperty(required = true, value = "(Deprecated) Specifies the string IDs of the users registered as channel operators. Operators can delete any messages in the channel, and can also receive all messages that have been throttled.")
  @JsonProperty(JSON_PROPERTY_OPERATORS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<String> getOperators() {
    return operators;
  }


  @JsonProperty(JSON_PROPERTY_OPERATORS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setOperators(List<String> operators) {
    this.operators = operators;
  }


  /**
   * Return true if this ocUpdateChannelByUrlData object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OcUpdateChannelByUrlData ocUpdateChannelByUrlData = (OcUpdateChannelByUrlData) o;
    return Objects.equals(this.channelUrl, ocUpdateChannelByUrlData.channelUrl) &&
        Objects.equals(this.name, ocUpdateChannelByUrlData.name) &&
        Objects.equals(this.coverUrl, ocUpdateChannelByUrlData.coverUrl) &&
        Objects.equals(this.coverFile, ocUpdateChannelByUrlData.coverFile) &&
        Objects.equals(this.customType, ocUpdateChannelByUrlData.customType) &&
        Objects.equals(this.data, ocUpdateChannelByUrlData.data) &&
        Objects.equals(this.operatorIds, ocUpdateChannelByUrlData.operatorIds) &&
        Objects.equals(this.operators, ocUpdateChannelByUrlData.operators);
  }

  @Override
  public int hashCode() {
    return Objects.hash(channelUrl, name, coverUrl, coverFile, customType, data, operatorIds, operators);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OcUpdateChannelByUrlData {\n");
    sb.append("    channelUrl: ").append(toIndentedString(channelUrl)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    coverUrl: ").append(toIndentedString(coverUrl)).append("\n");
    sb.append("    coverFile: ").append(toIndentedString(coverFile)).append("\n");
    sb.append("    customType: ").append(toIndentedString(customType)).append("\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("    operatorIds: ").append(toIndentedString(operatorIds)).append("\n");
    sb.append("    operators: ").append(toIndentedString(operators)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

